<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Private Match Room</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="privatematch.css">
</head>
<body>

    <div id="invitePopup">
        <div id="invitePopupContent">
            <div id="invitePopupHeader"></div>
            <div id="choiceButtons">
                <button id="acceptInvite">Accept</button>
                <button id="rejectInvite">Reject</button>
            </div>
        </div>
    </div>

    <!-- From Uiverse.io by NlghtM4re - also just a placeholder for the room creation animation for now-->     
    <div class="animationContainer">
        <div class="item" style="--i:0;"></div>
        <div class="item" style="--i:1;"></div>
        <div class="item" style="--i:2;"></div>
        <div class="item" style="--i:3;"></div>
        <div class="item" style="--i:4;"></div>
        <div class="item" style="--i:5;"></div>
        <div class="item" style="--i:6;"></div>
        <div class="item" style="--i:7;"></div>
        <div class="item" style="--i:8;"></div>
        <div class="item" style="--i:9;"></div>
        <div class="item" style="--i:10;"></div>
        <div class="item" style="--i:11;"></div>
        <div class="item" style="--i:12;"></div>
        <div class="item" style="--i:13;"></div>
        <div class="item" style="--i:14;"></div>
        <div class="item" style="--i:15;"></div>
        <div class="item" style="--i:16;"></div>
        <div class="item" style="--i:17;"></div>
        <div class="item" style="--i:18;"></div>
        <div class="item" style="--i:19;"></div>
        <div class="item" style="--i:20;"></div>
        <div class="loading-text">Creating room<span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></div>
    </div>

    <div id="privateMatch">
        <countdown-component id="private-countdown"></countdown-component>
        <match-timer-component></match-timer-component>
        
        <div id="playerContainer">
            <div id="playerTypingContainer">

            </div>
    
            <keyboard-component></keyboard-component>
    
        </div>

        <div id="progressLeaderboard">
            <h2 id="title">LEADERBOARD</h2>
            <div id="players">
                
            </div><!-- as in like every player's progress-->
        </div>

        <div id="finalLeaderboard">
            <h2 id="title">FINAL RANKINGS</h2>
            <div id="playerRankings">
                
            </div>
            <div class="final-buttons-container">
                <button id="playAgainBtn" style="display: none;">Play Again</button>
                <button id="finalMenuBtn" style="display: none;">Back to Menu</button>
            </div>
        </div>
    </div>
    
    <div id="privateRoom">
        <button id="exitBtn" class="exit-btn">EXIT</button>
    
        <div id="left-sidebar">
            <div class="players-header">PLAYERS ()</div>
            <div id="playerList">
                </div>
            </div>
        </div>
        
        <div class="center-content">
            <div class="room-title">PRIVATE ROOM</div>
            
            <div id="roomId" class="room-id-display">Room ID:</div>
            
            <div class="invite-section">
                <div class="invite-title">INVITE PLAYER</div>
                <div class="invite-input-container">
                    <input type="text" id="inviteInput" placeholder="Enter username..." maxlength="20">
                    <button id="inviteBtn">INVITE</button>
                </div>
            </div>
            
            <div id="roomSettings">
                <div class="section-title">ROOM SETTINGS</div>
                
                <div class="setting-row">
                    <div class="setting-label">Word Count</div>
                    <select class="wordcount-select">
                        <option value="10">10 Words</option>
                        <option value="25" selected>25 Words</option>
                        <option value="50">50 Words</option>
                        <option value="100">100 Words</option>
                    </select>
                </div>
                
                <div class="action-buttons">
                    <button id="startBtn" class = 'btn'>START MATCH</button>
                </div>
            </div>
        </div>
    </div>
    
    
    <script src="/socket.io/socket.io.js"></script>
    <script src="script.js"></script>
    <script src="keyboardComponent.js"></script>
    <script src="countdownComponent.js"></script>
    <script src="matchTimer.js"></script>
    <!-- <script src="debug_private_match.js"></script> -->
    <script>
        let myUsername = null;
        let isOwner = false;
        
        // --- Get references to owner controls and disable them by default ---
        const inviteButton = document.getElementById('inviteBtn');
        const startBtn = document.getElementById('startBtn');
        const wordCountSelect = document.querySelector('.wordcount-select');

        if(inviteButton) inviteButton.disabled = true;
        if(startBtn) startBtn.disabled = true;
        if(wordCountSelect) wordCountSelect.disabled = true;
        
        // Get username when page loads, then check ownership
        fetch('/auth/status')
            .then(res => res.json())
            .then(data => {
                if (data.authenticated && data.user) {
                    myUsername = data.user.displayName;
                    socket.emit('userData', data.user);

                    // Now that we have identified ourselves, we can ask for the room's data.
                    if (privateRoomId) {
                        socket.emit('getRoomPlayers', privateRoomId);
                        socket.emit('checkOwnership', { privateRoomId: privateRoomId });
                    }
                }
            });

        // Listen for the server's response to enable controls
        socket.on('ownershipResult', (data) => {
            if (data.isOwner) {
                isOwner = true;
                // Enable controls ONLY for the owner
                if(inviteButton) inviteButton.disabled = false;
                if(startBtn) startBtn.disabled = false;
                if(wordCountSelect) wordCountSelect.disabled = false;
            }
        });

        // Check URL for room ID and display it
        const urlParams = new URLSearchParams(window.location.search);
        const privateRoomId = urlParams.get('room');
        const isRedirected = urlParams.get('redirected') === 'true';
        
        // Check if page was refreshed
        const isRefresh = performance.navigation.type === 1; // 1 means reload
        
        if (isRefresh && privateRoomId) {
            // If refreshed, leave the room and redirect to menu
            fetch('/auth/status')
                .then(res => res.json())
                .then(data => {
                    if (data.authenticated && data.user) {
                        socket.emit('leavePrivateRoom', { 
                            privateRoomId: privateRoomId, 
                            username: data.user.displayName 
                        });
                    }
                });
            alert('You have been removed from the room because you refreshed the page.');
            window.location.href = '/';

        } else if (privateRoomId) {
            document.getElementById('roomId').textContent = 'Room ID: ' + privateRoomId;
        }

        // Clean the URL by removing query parameters after they've been used
        if (window.history.replaceState) {
            const cleanUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
            window.history.replaceState({path: cleanUrl}, '', cleanUrl);
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            // Add click listeners for the end-of-game buttons
            const playAgainBtn = document.getElementById('playAgainBtn');
            const finalMenuBtn = document.getElementById('finalMenuBtn');

            if (playAgainBtn) {
                playAgainBtn.onclick = () => {
                    // Hide the parent container of the leaderboard and typing area
                    const privateMatchContainer = document.getElementById('privateMatch');
                    if (privateMatchContainer) {
                        privateMatchContainer.classList.remove('active');
                    }

                    // Show the lobby
                    const privateRoom = document.getElementById('privateRoom');
                    if (privateRoom) {
                        privateRoom.style.display = 'block';
                    }

                    // Reset local game state for the next round
                    resetTypingVariables();
                };
            }

            if (finalMenuBtn) {
                finalMenuBtn.onclick = () => {
                    // Clean up all socket listeners before leaving the page
                    cleanupPrivateMatchListeners();
                    socket.emit('leavePrivateRoom', { privateRoomId });
                    if (window.onLeaveRoom) {
                        window.onLeaveRoom();
                    }
                    window.location.href = '/';
                };
            }

            const animationContainer = document.querySelector('.animationContainer');
            
            if (animationContainer) {
                if (isRedirected) {
                    // Skip animation if redirected from accepting invite
                    animationContainer.style.display = 'none';
                } else {
                    // Hide animation after 3 seconds with fade out (for room creators)
                    setTimeout(() => {
                        animationContainer.classList.add('fade-out');
                        setTimeout(() => {
                            animationContainer.style.display = 'none';
                        }, 1000); // Wait for fade transition to complete
                    }, 3000);
                }
            }
        });

        // The inviteButton click listener belongs here as it's specific to this page
        // and needs access to myUsername and privateRoomId.
        inviteButton.addEventListener('click', () => {
            const username = inviteInput.value.trim();
            const playerItems = document.querySelectorAll('.player-item');

            let isAlreadyInRoom = false;
            for (const item of playerItems) {
                if (item.dataset.username === username) {
                    isAlreadyInRoom = true;
                    break;
                }
            }

            if (username === myUsername) {
                alert('You cannot invite yourself');
                return;
            }

            if (isAlreadyInRoom) {
                alert('This player is already in the room');
                return;
            }
            
            if (username.length >= 5) {
                socket.emit('invitePlayer', {
                    privateRoomId: privateRoomId,
                    inviter: myUsername,
                    invitee: username
                });
                alert('Invitation sent to ' + username);
                inviteInput.value = '';
            } else if (username.length > 0) {
                alert('Please enter a valid username (at least 5 characters)');
            } else {
                alert('Please enter a username to invite.');
            }
        });

        startBtn.addEventListener('click', () => {
            // The button is disabled for non-owners, so no check is needed here.
            // Get current player count
            const playerItems = document.querySelectorAll('.player-item');
            const playerCount = playerItems.length;
            
            if (playerCount < 2) {
                alert('You must have at least 2 players to start the match');
            }

            else {
                // Get selected word count
                const selectedWordCount = document.querySelector('.wordcount-select').value;
                
                socket.emit('privateMatchStarted', { 
                    privateRoomId: privateRoomId,
                    wordCount: selectedWordCount 
                });
            }

        })

        wordCountSelect.addEventListener('change', ()=> {
            if (isOwner) {
                socket.emit('updatePrivateRoomWordCount', {
                    privateRoomId: privateRoomId,
                    wordCount: wordCountSelect.value
                })
            }
        })

        socket.on('privateRoomWordCountChanged', (wordCount) => {
            wordCountSelect.value = String(wordCount);

        });

        // Handle player list updates
        socket.on('playerJoined', (data) => {
            updatePlayersList(data.players, data.playerCount);
        });

        // Handle player leaving
        socket.on('playerLeft', (data) => {
            updatePlayersList(data.players, data.playerCount);
            
            // This is a simple, informational alert for all players.
            // The server is responsible for directly giving the new host their powers.
            if (data.newOwner && data.username) {
                alert(`${data.username} has left. ${data.newOwner} is now the host.`);
            } else if (data.username) {
                 // Standard notification if someone leaves during a match
                const privateMatch = document.getElementById('privateMatch');
                if (privateMatch.classList.contains('active')) {
                    alert(`${data.username} left the match!`);
                }
            }
        });

        socket.on('privateMatchStarted', (data) => {
            // This class is what hides the lobby and shows the game screen.
            // We need to remove it to go back.
            document.getElementById('privateMatch').classList.add('active');
            
            // Wait until the countdown component is fully defined and ready.
            customElements.whenDefined('countdown-component').then(() => {
                // Hide all non-gameplay screens
                document.getElementById('privateRoom').style.display = 'none';
                document.getElementById('finalLeaderboard').style.display = 'none';
                
                // Show the main match screen
                document.getElementById('progressLeaderboard').style.display = 'block';
                
                // Initialize and show everything immediately (but disable typing)
                resetTypingVariables();
                displayRandomWords(data.words);
                
                // Show keyboard immediately but disable it
                setTimeout(() => {
                    const keyboard = document.getElementById('keyboard');
                    if (keyboard) {
                        keyboard.style.display = 'block';
                        keyboard.style.pointerEvents = 'none'; // Disable keyboard interactions
                        keyboard.style.opacity = '0.6'; // Visual indication it's disabled
                    }
                }, 100);
                
                // Disable typing during countdown
                window.countdownActive = true;
                
                // Start countdown using the countdown component
                const countdown = document.getElementById('private-countdown');
                countdown.start(() => {
                    // Re-enable typing after countdown
                    window.countdownActive = false;
                    
                    // Re-enable keyboard
                    const keyboard = document.getElementById('keyboard');
                    if (keyboard) {
                        keyboard.style.pointerEvents = 'auto';
                        keyboard.style.opacity = '1';
                    }
                    
                    // Start the progress timer for real-time leaderboard updates
                    startPrivateMatchProgressTimer();
                    
                    // Start the 2-minute match timer
                    const timer = document.querySelector('match-timer-component');
                    if (timer) {
                        timer.startTimer();
                    }
                });
            });
        });

        socket.on('privateMatchEnded', (data) => {
            showFinalLeaderboard(data.finalRankings, privateRoomId);
        });

        // Handle EXIT button
        document.getElementById('exitBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to leave the room?')) {
                socket.emit('leavePrivateRoom', { privateRoomId: privateRoomId });
                if (window.onLeaveRoom) {
                    window.onLeaveRoom();
                }
                window.location.href = '/';
            }
        });

        function updatePlayersList(players, playerCount) {
            const playerList = document.getElementById('playerList');
            const playersHeader = document.querySelector('.players-header');
            
            // Update header with player count
            if (playersHeader) {
                playersHeader.textContent = `PLAYERS (${playerCount})`;
            }

            const existingPlayers = new Set(Array.from(playerList.querySelectorAll('.player-item')).map(div => div.dataset.username));

            const newPlayers = new Set(players);

            existingPlayers.forEach(player => {
                if (!newPlayers.has(player)) {
                    playerToRemove = playerList.querySelector(`[data-username="${player}"]`);
                    if (playerToRemove) {
                        playerToRemove.classList.add('leaving');
                        setTimeout(() => {
                            playerToRemove.remove();
                        }, 500);
                    }
                }
            })

            newPlayers.forEach(player => {
                if (!existingPlayers.has(player)) {// Add each player
                    const playerItem = document.createElement('div');
                    playerItem.className = 'player-item newly-added';
                    playerItem.textContent = player;
                    playerItem.dataset.username = player;
                    playerList.appendChild(playerItem);

                    setTimeout(() => {
                        playerItem.classList.remove('newly-added');
                    }, 500)
                }
            });
        }
    </script>
</body>
</html>